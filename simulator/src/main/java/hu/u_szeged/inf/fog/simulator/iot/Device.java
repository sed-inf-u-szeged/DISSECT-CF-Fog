package hu.u_szeged.inf.fog.simulator.iot;

import hu.mta.sztaki.lpds.cloud.simulator.DeferredEvent;
import hu.mta.sztaki.lpds.cloud.simulator.Timed;
import hu.mta.sztaki.lpds.cloud.simulator.energy.specialized.PhysicalMachineEnergyMeter;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.PhysicalMachine;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.VirtualMachine;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.resourcemodel.ResourceConsumption;
import hu.mta.sztaki.lpds.cloud.simulator.iaas.resourcemodel.ResourceConsumption.ConsumptionEvent;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode.NetworkException;
import hu.mta.sztaki.lpds.cloud.simulator.io.NetworkNode.State;
import hu.mta.sztaki.lpds.cloud.simulator.io.Repository;
import hu.mta.sztaki.lpds.cloud.simulator.io.StorageObject;
import hu.mta.sztaki.lpds.cloud.simulator.io.VirtualAppliance;
import hu.u_szeged.inf.fog.simulator.application.Application;
import hu.u_szeged.inf.fog.simulator.iot.mobility.GeoLocation;
import hu.u_szeged.inf.fog.simulator.iot.mobility.MobilityStrategy;
import hu.u_szeged.inf.fog.simulator.iot.strategy.DeviceStrategy;
import java.util.ArrayList;

/**
 * This class is an abstract representation of an IoT device that is capable of generating data 
 * within a certain time interval and then forwarding it to a cloud or fog node. 
 * There are currently two implementations: <br/>
 * &ensp; SmartDevice - not capable of processing data locally <br/>
 * &ensp; EdgeDevice - capable of processing data locally 
 */
public abstract class Device extends Timed {

    /**
     * It stores the time when the last IoT device unsubscribes, i.e.
     * when it stops generating, forwarding or processing data.
     */
    public static long lastAction;

    /**
     * All IoT devices created are available in this list.
     */
    public static ArrayList<Device> allDevices = new ArrayList<Device>();

    /**
     * The amount of the total generated data by IoT devices.
     */
    public static long totalGeneratedSize = 0;

    /**
     * The current position of the device.
     */
    public GeoLocation geoLocation;

    /**
     * The time when the devices starts generating data.
     */
    public long startTime;

    /**
     * The time when the device stops generating data.
     */
    public long stopTime;

    /**
     * The size of the data produced by a sensor measurement.
     */
    public long fileSize;

    /**
     * The elapsed time between two sensor measurements.
     */
    public long freq;

    /**
     * The minimum latency for the device to send data. 
     * Later it will be weighted by the physical distance (see MobilityEvent class).
     */
    public int latency;

    /**
     * It can represent a smart phone or Raspberry Pi, and it is needed
     * to measure energy consumption, and to use networking and storing abilities.
     */
    public PhysicalMachine localMachine;

    /**
     *The storage of the node to which the data generated by this device is forwarded.
     */
    public Repository caRepository;

    /**
     * The IoT application to which the device is connected and
     * which processes the data using virtual machines.
     */
    public Application application;
    
    /**
     * The strategy for choosing which IoT application will process the generated data.
     */
    public DeviceStrategy deviceStrategy;

    /**
     * The strategy that determines the movement of the device during the simulation.
     */
    public MobilityStrategy mobilityStrategy;   

    /**
     * A list containing the positions of the device during the simulation.
     * The route of the device is displayed during map generation.
     */
    public ArrayList<GeoLocation> devicePath;

    /**
     * True if we store the path of the device. 
     * It is recommended to use only for logging and testing.
     */
    public boolean isPathLogged;

    /**
     * Measures how many messages (i.e. data) are sent to nodes.
     */
    public int messageCount;

    /**
     * The energy consumed by this device.
     */
    public double energyConsumption;

    /**
     * The amount of data already sent to nodes.
     */
    long sentData;

    /**
     * The amount of locally processed data. In case of SmartDevice, it remains zero.
     */
    public long locallyProcessedData;
    
    /**
     * The amount of the generated data by this IoT device so far.
     */
    public long generatedData;

    /**
     * The device starts its operation defined in its tick() method
     * at the time specified with the startTime parameter.
     */
    protected void startMeter() {
        if (this.isSubscribed() == false) {
            new DeferredEvent(this.startTime) {

                @Override
                protected void eventAction() {
                    subscribe(freq);
                    readEnergy();
                    try {
                        localMachine.localDisk.setState(State.RUNNING);
                    } catch (NetworkException e) {
                        e.printStackTrace();
                    }
                }
            };
        }
    }

    /**
     * The device is terminated and it finishes its operation defined in its tick() method. 
     */
    public void stopMeter() {
        unsubscribe();
        Device.lastAction = Timed.getFireCount();
    }
    
    /**
     * If the broker VM for the selected IoT application is running, 
     * the method responsible for sending data is called. 
     * If the application is not running, it will start it.
     */
    protected void startDataTransfer() throws NetworkException {
        if (this.deviceStrategy.chosenApplication.computingAppliance.broker.vm.getState()
                .equals(VirtualMachine.State.RUNNING)) {
            this.realTransfer();
        } else if (!this.deviceStrategy.chosenApplication.isSubscribed()) {
            this.deviceStrategy.chosenApplication.subscribeApplication();
        }
    }
    
    /**
     * It starts a file transfer with each content of the local storage.  
     */
    private void realTransfer() {
        this.localMachine.localDisk.contents().stream()
            .filter(storageObject -> !(storageObject instanceof VirtualAppliance)).forEach(storageObject -> {
                DeviceDataEvent soe = new DeviceDataEvent(this, storageObject);
                
                try {
                    // this.localRepo.requestContentDelivery(so.id, this.caRepository, soe);
                    NetworkNode.initTransfer(storageObject.size, ResourceConsumption.unlimitedProcessing,
                            this.localMachine.localDisk, this.caRepository, soe);
                } catch (NetworkException e) {
                    e.printStackTrace();
                }
            }
        );
    }
    
    /**
     * The method calculates how much data remains unprocessed due to the position
     * of the device.
     * 
     * @return the amount of unprocessed data in the local storage.
     */
    public long calculateStuckData() {
        long temp = 0;
        for (StorageObject so : this.localMachine.localDisk.contents()) {
            if (!(so instanceof VirtualAppliance)) {
                temp += so.size;
            }
        }
        return temp;
    }
    
    /**
     * This initializes a PM energy meter, which requires a timed event (DataCollector class) 
     * to retrieve the total energy consumption of the PM.
     */
    protected void readEnergy() {
        final PhysicalMachineEnergyMeter pmEnergyMeter = new PhysicalMachineEnergyMeter(this.localMachine);
        final Device device = this;
        
        /**
         * A timed event to periodically check the energy consumption of the device.
         */
        class EnergyCollector extends Timed {
            
            /**
             * It starts the energy measurement with the frequency of the device.
             */
            private void start() {
                subscribe(device.freq);
            }

            /**
             * It retrieves the energy consumption from the energy meter.
             * It stops the energy measurement if the device was also stopped.
             */
            @Override
            public void tick(final long fires) {
                energyConsumption = pmEnergyMeter.getTotalConsumption();
                if (!device.isSubscribed()) {
                    unsubscribe();
                    pmEnergyMeter.stopMeter();
                }
            }
        }
        
        final EnergyCollector dc = new EnergyCollector();
        pmEnergyMeter.startMeter(device.freq, true);
        dc.start();
    }

    /**
     * This class is required for file transfer, it defines what action is
     * needed to perform in case of successful or unsuccessful file transfer.
     */
    class DeviceDataEvent implements ConsumptionEvent {

        /**
         * The file that is under transfer.
         */
        private StorageObject so;
        
        /**
         * Reference to the device performing the file transfer.
         */
        private Device device;

        /**
         * It creates an event for file transfer.
         * @param device the device performing the file transfer
         * @param so the file that is under transfer.
         */
        protected DeviceDataEvent(Device device, StorageObject so) {
            this.so = so;
            this.device = device;
        }

        /**
         * Executed when the transfer is successful.
         */
        @Override
        public void conComplete() {
            localMachine.localDisk.deregisterObject(this.so);
            application.receivedData += this.so.size;
            this.device.sentData += this.so.size;
        }

        /**
         * Executed when the transfer is unsuccessful. Since it should not happen, 
         * thus it is considered as a program error, and causes termination.
         */
        @Override
        public void conCancelled(ResourceConsumption problematic) {
            try {
                System.err.println(
                        "Error in Device.java: Deleting StorageObject from the local repository is unsuccessful.");
                System.exit(0);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

}